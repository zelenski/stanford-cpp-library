<html>
<head>
<title>HashSet&lt;ValueType&gt;</title>
<link rel="stylesheet" type="text/css" href="cppdoc.css" />
</head>
<body>
<table class=banner>
<tr>
<td valign=middle><image src="images/StanfordTreeLogo.png" height=32></td>
<td valign=middle><div class=bannerText>
The Stanford <code>cslib</code> package
</div></td>
</tr></table>
<hr>
<div class=include><a href="hashset.html">#include "hashset.h"</a></div>
<h1 class=header><code>class HashSet&lt;ValueType&gt;</code></h1>
This class implements an efficient abstraction for storing sets
of distinct elements.  This class is identical to the <code>Set</code>
class except for the fact that it uses a hash table as its underlying
representation.  The advantage of the <code>HashSet</code> class is that
it operates in constant time, as opposed to the <i>O</i>(log <i>N</i>)
time for the <code>Set</code> class.  The disadvantage of
<code>HashSet</code> is that iterators return the values in a
seemingly random order.
<table class=index width=100%>
<tr><td class=indexHead colspan=2>Constructor</td></tr>
<tr><td class=indexKey><nobr><a href="#Constructor:HashSet">HashSet()</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Initializes an empty set of the specified element type.</td></tr>
<tr><td class=indexHead colspan=2>Methods</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:add">add(value)</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Adds an element to this set, if it was not already there.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:clear">clear()</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Removes all elements from this set.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:contains">contains(value)</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Returns <code>true</code> if the specified value is in this set.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:first">first()</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Returns the first value in the set in the order established by the <code>foreach</code> macro.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:isEmpty">isEmpty()</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Returns <code>true</code> if this set contains no elements.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:isSubsetOf">isSubsetOf(set2)</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Implements the subset relation on sets.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:mapAll">mapAll(fn)</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Iterates through the elements of the set and calls <code>fn(value)</code> for each one.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:remove">remove(value)</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Removes an element from this set.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:size">size()</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Returns the number of elements in this set.</td></tr>
<tr><td class=indexKey><nobr><a href="#Method:toString">toString()</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Converts the set to a printable string representation.</td></tr>
<tr><td class=indexHead colspan=2>Operators</td></tr>
<tr><td class=indexKey><nobr><a href="#Operator:!=">set1 != set2</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Returns <code>true</code> if <code>set1</code> and <code>set2</code> are different.</td></tr>
<tr><td class=indexKey><nobr><a href="#Operator:*">set1 * set2</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Returns the intersection of sets <code>set1</code> and <code>set2</code>, which is the set of all elements that appear in both.</td></tr>
<tr><td class=indexKey><nobr><a href="#Operator:*=">set1 *= set2;</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Removes any elements from <code>set1</code> that are not present in <code>set2</code>.</td></tr>
<tr><td class=indexKey><nobr><a href="#Operator:+">set1 + set2</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Returns the union of sets <code>set1</code> and <code>set2</code>, which is the set of elements that appear in at least one of the two sets.</td></tr>
<tr><td class=indexKey><nobr><a href="#Operator:+=">set1 += set2;</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Adds all of the elements from <code>set2</code> (or the single specified value) to <code>set1</code>.</td></tr>
<tr><td class=indexKey><nobr><a href="#Operator:-">set1 - set2</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Returns the difference of sets <code>set1</code> and <code>set2</code>, which is all of the elements that appear in <code>set1</code> but not <code>set2</code>.</td></tr>
<tr><td class=indexKey><nobr><a href="#Operator:-=">set1 -= set2;</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Removes the elements from <code>set2</code> (or the single specified value) from <code>set1</code>.</td></tr>
<tr><td class=indexKey><nobr><a href="#Operator:==">set1 == set2</a>&nbsp;</nobr></td><td class=indexSynopsis width=100%>Returns <code>true</code> if <code>set1</code> and <code>set2</code> contain the same elements.</td></tr>
</table>
<h2>Constructor detail</h2>
<hr>
<a name="Constructor:HashSet"></a>
<pre class=detailCode>
HashSet();
</pre>
<div class=detailHTML>
Initializes an empty set of the specified element type.
<p>Usage:<br>
</div>
<pre class=usageCode>
HashSet&lt;ValueType&gt; set;
</pre>
<hr>
</table>
<h2>Method detail</h2>
<hr>
<a name="Method:size"></a>
<pre class=detailCode>
int size() const;
</pre>
<div class=detailHTML>
Returns the number of elements in this set.
<p>Usage:<br>
</div>
<pre class=usageCode>
count = set.size();
</pre>
<hr>
<a name="Method:isEmpty"></a>
<pre class=detailCode>
bool isEmpty() const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if this set contains no elements.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (set.isEmpty()) ...
</pre>
<hr>
<a name="Method:add"></a>
<pre class=detailCode>
void add(const ValueType &amp; value);
void insert(const ValueType &amp; value);
</pre>
<div class=detailHTML>
Adds an element to this set, if it was not already there.  For
compatibility with the STL <code>set</code> class, this method
is also exported as <code>insert</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
set.add(value);
</pre>
<hr>
<a name="Method:remove"></a>
<pre class=detailCode>
void remove(const ValueType &amp; value);
</pre>
<div class=detailHTML>
Removes an element from this set.  If the value was not
contained in the set, no error is generated and the set
remains unchanged.
<p>Usage:<br>
</div>
<pre class=usageCode>
set.remove(value);
</pre>
<hr>
<a name="Method:contains"></a>
<pre class=detailCode>
bool contains(const ValueType &amp; value) const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if the specified value is in this set.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (set.contains(value)) ...
</pre>
<hr>
<a name="Method:isSubsetOf"></a>
<pre class=detailCode>
bool isSubsetOf(const HashSet &amp; set2) const;
</pre>
<div class=detailHTML>
Implements the subset relation on sets.  It returns
<code>true</code> if every element of this set is
contained in <code>set2</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (set.isSubsetOf(set2)) ...
</pre>
<hr>
<a name="Method:clear"></a>
<pre class=detailCode>
void clear();
</pre>
<div class=detailHTML>
Removes all elements from this set.
<p>Usage:<br>
</div>
<pre class=usageCode>
set.clear();
</pre>
<hr>
<a name="Method:first"></a>
<pre class=detailCode>
ValueType first() const;
</pre>
<div class=detailHTML>
Returns the first value in the set in the order established by the
<code>foreach</code> macro.  If the set is empty, <code>first</code>
generates an error.
<p>Usage:<br>
</div>
<pre class=usageCode>
ValueType value = set.first();
</pre>
<hr>
<a name="Method:toString"></a>
<pre class=detailCode>
string toString();
</pre>
<div class=detailHTML>
Converts the set to a printable string representation, such as <code>&quot;{value1, value2, value3}&quot;</code>.
The values appear in an unpredictable order.
<p>Usage:<br>
</div>
<pre class=usageCode>
string str = set.toString();
</pre>
<hr>
<a name="Method:mapAll"></a>
<pre class=detailCode>
void mapAll(void (*fn)(ValueType)) const;
void mapAll(void (*fn)(const ValueType &amp;)) const;
void mapAll(FunctorType fn) const;
</pre>
<div class=detailHTML>
Iterates through the elements of the set and calls <code>fn(value)</code>
for each one.  The values are processed in ascending order, as defined
by the comparison function.
<p>Usage:<br>
</div>
<pre class=usageCode>
set.mapAll(fn);
</pre>
<hr>
</table>
<h2>Operator detail</h2>
<hr>
<a name="Operator:=="></a>
<pre class=detailCode>
bool operator==(const HashSet &amp; set2) const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if <code>set1</code> and <code>set2</code>
contain the same elements.
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 == set2
</pre>
<hr>
<a name="Operator:!="></a>
<pre class=detailCode>
bool operator!=(const HashSet &amp; set2) const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if <code>set1</code> and <code>set2</code>
are different.
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 != set2
</pre>
<hr>
<a name="Operator:+"></a>
<pre class=detailCode>
HashSet operator+(const HashSet &amp; set2) const;
HashSet operator+(const ValueType &amp; element) const;
</pre>
<div class=detailHTML>
Returns the union of sets <code>set1</code> and <code>set2</code>, which
is the set of elements that appear in at least one of the two sets.  The
right hand set can be replaced by an element of the value type, in which
case the operator returns a new set formed by adding that element.
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 + set2
set1 + element
</pre>
<hr>
<a name="Operator:*"></a>
<pre class=detailCode>
HashSet operator*(const HashSet &amp; set2) const;
</pre>
<div class=detailHTML>
Returns the intersection of sets <code>set1</code> and <code>set2</code>,
which is the set of all elements that appear in both.
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 * set2
</pre>
<hr>
<a name="Operator:-"></a>
<pre class=detailCode>
HashSet operator-(const HashSet &amp; set2) const;
HashSet operator-(const ValueType &amp; element) const;
</pre>
<div class=detailHTML>
Returns the difference of sets <code>set1</code> and <code>set2</code>,
which is all of the elements that appear in <code>set1</code> but
not <code>set2</code>.  The right hand set can be replaced by an
element of the value type, in which case the operator returns a new
set formed by removing that element.
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 - set2
set1 - element
</pre>
<hr>
<a name="Operator:+="></a>
<pre class=detailCode>
HashSet &amp; operator+=(const HashSet &amp; set2);
HashSet &amp; operator+=(const ValueType &amp; value);
</pre>
<div class=detailHTML>
Adds all of the elements from <code>set2</code> (or the single
specified value) to <code>set1</code>.  As a convenience, the
<code>HashSet</code> package also overloads the comma operator so
that it is possible to initialize a set like this:

<pre>
   HashSet&lt;int&gt; digits;
   digits += 0, 1, 2, 3, 4, 5, 6, 7, 8, 9;
</pre>
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 += set2;
set1 += value;
</pre>
<hr>
<a name="Operator:*="></a>
<pre class=detailCode>
HashSet &amp; operator*=(const HashSet &amp; set2);
</pre>
<div class=detailHTML>
Removes any elements from <code>set1</code> that are not present in
<code>set2</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 *= set2;
</pre>
<hr>
<a name="Operator:-="></a>
<pre class=detailCode>
HashSet &amp; operator-=(const HashSet &amp; set2);
HashSet &amp; operator-=(const ValueType &amp; value);
</pre>
<div class=detailHTML>
Removes the elements from <code>set2</code> (or the single
specified value) from <code>set1</code>.  As a convenience, the
<code>HashSet</code> package also overloads the comma operator so
that it is possible to remove multiple elements from a set
like this:

<pre>
   digits -= 0, 2, 4, 6, 8;
</pre>

which removes the values 0, 2, 4, 6, and 8 from the set
<code>digits</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 -= set2;
set1 -= value;
</pre>
<hr>
</table>
</body>
</html>
