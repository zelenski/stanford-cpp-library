<html>
<head>
<title>HashMap</title>
<link rel="stylesheet" type="text/css" href="cppdoc.css" />
</head>
<body>
<table class=banner>
<tr>
<td valign=middle><image src="images/StanfordTreeLogo.png" height=32></td>
<td valign=middle><div class=bannerText>
The Stanford <code>cslib</code> package
</div></td>
</tr></table>
<hr>
<div class=include><a href="hashmap.html">#include "hashmap.h"</a></div>
<h1 class=header><code>class HashMap&lt;<var>KeyType</var>,&nbsp;<var>ValueType</var>&gt;</code></h1>
This class implements an efficient association between
<b><i>keys</i></b> and <b><i>values</i></b>.  This class is
identical to the <a href="Map-class.html"><code>Map</code></a> class
except for the fact that it uses a hash table as its underlying
representation.  Although the <code>HashMap</code> class operates in
constant time, the iterator for <code>HashMap</code> returns the
values in a seemingly random order.

<table class=index width=100%>
	<tr>
		<td class=indexHead colspan=3>Constructor</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Constructor:HashMap">HashMap()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Initializes a new empty map that associates keys and values of the specified types.</td>
	</tr>
	<tr>
		<td class=indexHead colspan=3>Methods</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:clear">clear()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Removes all entries from this map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:containsKey">containsKey(<var>key</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Returns <code>true</code> if there is an entry for <code>key</code> in this map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:equals">equals(<var>map</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N log N)</td>
		<td class=indexSynopsis width=100%>Returns <code>true</code> if the two maps contain the same elements.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:get">get(<var>key</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Returns the value associated with <code>key</code> in this map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:isEmpty">isEmpty()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Returns <code>true</code> if this map contains no entries.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:keys">keys()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Returns a <code>Vector</code> copy of all keys in this map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:mapAll">mapAll(<var>fn</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Iterates through the map entries and calls <code>fn(key, value)</code> for each one.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:put">put(<var>key</var>,&nbsp;<var>value</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Associates <code>key</code> with <code>value</code> in this map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:remove">remove(<var>key</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Removes any entry for <code>key</code> from this map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:size">size()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Returns the number of entries in this map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:toString">toString()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Converts the map to a printable string representation.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:values">values()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Returns a <code>Vector</code> copy of all values in this map.</td>
	</tr>
	<tr>
		<td class=indexHead colspan=3>Operators</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:[]"><var>map</var>[<var>key</var>]</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Selects the value associated with <code>key</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:=="><var>map1</var> == <var>map1</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Returns <code>true</code> if <code>map1</code> and <code>map2</code> contain the same elements.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:!="><var>map1</var> != <var>map2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Returns <code>true</code> if <code>map1</code> and <code>map2</code> are different.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><var>ostream</var>&nbsp;&lt;&lt;&nbsp;<var>map</var></nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Outputs the contents of the map to the given output stream.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><var>istream</var>&nbsp;&gt;&gt;&nbsp;<var>map</var></nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Reads the contents of the given input stream into the map.</td>
	</tr>
</table>

<h2>Constructor detail</h2>
<hr>
<a name="Constructor:HashMap"></a>
<pre class=detailCode>
HashMap();
</pre>
<div class=detailHTML>
Initializes a new empty map that associates keys and values of
the specified types.  The type used for the key must define
the <code>==</code> operator, and there must be a free function
with the following signature:

<pre>
    int hashCode(KeyType key);
</pre>

that returns a positive integer determined by the key.  This interface
exports <code>hashCode</code> functions for <code>string</code> and
the C++ primitive types.
<p>Usage:<br>
</div>
<pre class=usageCode>
HashMap&lt;KeyType, ValueType&gt; map;
</pre>
<hr>
</table>

<h2>Method detail</h2>

<hr>
<a name="Method:clear"></a>
<pre class=detailCode>
void clear();
</pre>
<div class=detailHTML>
Removes all entries from this map.
<p>Usage:<br>
</div>
<pre class=usageCode>
map.clear();
</pre>

<hr>
<a name="Method:containsKey"></a>
<pre class=detailCode>
bool containsKey(KeyType key) const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if there is an entry for <code>key</code>
in this map.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (map.containsKey(key)) ...
</pre>

<hr>
<a name="Method:equals"></a>
<pre class=detailCode>
bool equals(const HashMap&amp; map) const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if the two maps contain exactly the same set of key/value pairs.
Identical in behavior to the <code>==</code> operator.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (map.equals(map2)) ...
</pre>

<hr>
<a name="Method:get"></a>
<pre class=detailCode>
ValueType get(KeyType key) const;
</pre>
<div class=detailHTML>
Returns the value associated with <code>key</code> in this map.
If <code>key</code> is not found, <code>get</code> returns the
default value for <code>ValueType</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
ValueType value = map.get(key);
</pre>

<hr>
<a name="Method:isEmpty"></a>
<pre class=detailCode>
bool isEmpty() const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if this map contains no entries.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (map.isEmpty()) ...
</pre>

<hr>
<a name="Method:keys"></a>
<pre class=detailCode>
Vector&lt;KeyType&gt; keys() const;
</pre>
<div class=detailHTML>
Returns a <code>Vector</code> copy of all keys in this map.
The elements will appear in the same order that a for-each loop over the map would produce them, though that order is seemingly random for hash maps.
Because a map cannot contain duplicate keys, the elements of the vector will be unique.
<p>Usage:<br>
</div>
<pre class=usageCode>
Vector&lt;KeyType&gt; keys = map.keys();
</pre>
<p class="since">
	Available since: 2014/02/01 version of C++ library
</p>

<hr>
<a name="Method:mapAll"></a>
<pre class=detailCode>
void mapAll(void (*fn)(KeyType, ValueType)) const;
void mapAll(void (*fn)(const KeyType&amp;, const ValueType&amp;)) const;
void mapAll(FunctorType fn) const;
</pre>
<div class=detailHTML>
Iterates through the map entries and calls <code>fn(key, value)</code>
for each one.  The keys are processed in an undetermined order.
<p>Usage:<br>
</div>
<pre class=usageCode>
map.mapAll(fn);
</pre>

<hr>
<a name="Method:put"></a>
<pre class=detailCode>
void put(KeyType key, ValueType value);
</pre>
<div class=detailHTML>
Associates <code>key</code> with <code>value</code> in this map.
Any previous value associated with <code>key</code> is replaced
by the new value.
<p>Usage:<br>
</div>
<pre class=usageCode>
map.put(key, value);
</pre>

<hr>
<a name="Method:remove"></a>
<pre class=detailCode>
void remove(KeyType key);
</pre>
<div class=detailHTML>
Removes any entry for <code>key</code> from this map.
<p>Usage:<br>
</div>
<pre class=usageCode>
map.remove(key);
</pre>

<hr>
<a name="Method:size"></a>
<pre class=detailCode>
int size() const;
</pre>
<div class=detailHTML>
Returns the number of entries in this map.
<p>Usage:<br>
</div>
<pre class=usageCode>
int nEntries = map.size();
</pre>

<hr>
<a name="Method:toString"></a>
<pre class=detailCode>
string toString();
</pre>
<div class=detailHTML>
Converts the map to a printable string representation, such as <code>&quot;{k1:v1, k2:v2, k3:v3}&quot;</code>.
The key/value pairs appear in an unpredictable order.
<p>Usage:<br>
</div>
<pre class=usageCode>
string str = map.toString();
</pre>

<hr>
<a name="Method:values"></a>
<pre class=detailCode>
Vector&lt;ValueType&gt; values() const;
</pre>
<div class=detailHTML>
Returns a <code>Vector</code> copy of all values in this map.
The elements will appear in the same order that a for-each loop over the map would produce them, though that order is seemingly random for hash maps.
A map can contain duplicate values, so the elements of the vector are not guaranteed to be unique.
<p>Usage:<br>
</div>
<pre class=usageCode>
Vector&lt;ValueType&gt; values = map.values();
</pre>
<p class="since">
	Available since: 2014/02/01 version of C++ library
</p>

<hr>
</table>
<h2>Operator detail</h2>

<hr>
<a name="Operator:[]"></a>
<pre class=detailCode>
ValueType&amp; operator[](KeyType key);
ValueType operator[](KeyType key) const;
</pre>
<div class=detailHTML>
Selects the value associated with <code>key</code>.  This syntax
makes it easy to think of a map as an "associative array"
indexed by the key type.  If <code>key</code> is already present
in the map, this function returns a reference to its associated
value.  If key is not present in the map, a new entry is created
whose value is set to the default for the value type.
<p>Usage:<br>
</div>
<pre class=usageCode>
map[key]
</pre>

<hr>
</table>
</body>
</html>
