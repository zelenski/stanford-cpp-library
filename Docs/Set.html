<html>
<head>
<title>Set</title>
<link rel="stylesheet" type="text/css" href="cppdoc.css" />
</head>
<body>
<table class=banner>
<tr>
<td valign=middle><image src="img/StanfordTreeLogo.png" height=32></td>
<td valign=middle><div class=bannerText>
The Stanford <code>libcs106</code> library, Academic Year 2024-25
</div></td>
</tr></table>
<hr>
<div class=include>#include "set.h"</div>
<h1 class=header><code>class Set&lt;<var>ValueType</var>&gt;</code></h1>
This class stores a collection of distinct elements.

<p>The set uses a binary search tree (BST) structure internally.
Because of this choice of internal representation, the <code>ValueType</code> for the type of elements stored in a <code>Set</code> must define a natural ordering through a <a target="_blank" href="http://www.cplusplus.com/reference/functional/less/"><code>less</code> function</a> and/or <code>&lt;</code> operator so that the elements can be compared and ordered. The range-based for loop will iterate over the elements in sorted order. The Set operations to add/find/remove an element run in O(logN) time.


<table class=index width=100%>
	<tr>
		<td class=indexHead colspan=3>Constructor</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Constructor:Set">Set()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Initializes a new set of the specified element type.</td>
	</tr>
	<tr>
		<td class=indexHead colspan=3>Methods</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:add">add(<var>value</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(log N)</td>
		<td class=indexSynopsis width=100%>Adds an element to this set, if it was not already there.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:clear">clear()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Removes all elements from this set.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:contains">contains(<var>value</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(log N)</td>
		<td class=indexSynopsis width=100%>Returns <code>true</code> if the specified value is in this set.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:difference">difference(<var>otherSet</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N log N)</td>
		<td class=indexSynopsis width=100%>Subtracts <code>otherSet</code> from this set. The difference removes those elements that appear in <code>otherSet</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:equals">equals(<var>set</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Returns <code>true</code> if the two sets contain the same elements.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:first">first()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Returns the first value in this set when considered in sorted order.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:intersect">intersect(<var>otherSet</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N log N)</td>
		<td class=indexSynopsis width=100%>Intersects <code>otherSet</code> with this set. The intersection retains only those elements also contained in <code>otherSet</code>.</td>
	<tr>
		<td class=indexKey><nobr><a href="#Method:isEmpty">isEmpty()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Returns <code>true</code> if this set contains no elements.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:isSubsetOf">isSubsetOf(<var>otherSet</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Returns <code>true</code> if this set is a subset of <code>otherSet</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:isSupersetOf">isSupersetOf(<var>otherSet</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Returns <code>true</code> if this set is a superset of <code>otherSet</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:last">last()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(log N)</td>
		<td class=indexSynopsis width=100%>Returns the last value in this set when considered in sorted order.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:mapAll">mapAll(<var>fn</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Calls <code>fn(value)</code> for each element of this set.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:remove">remove(<var>value</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(log N)</td>
		<td class=indexSynopsis width=100%>Removes an element from this set.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:size">size()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Returns the number of elements in this set.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:toString">toString()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Returns a printable string representation of this set.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:unionWith">unionWith(<var>otherSet</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N log N)</td>
		<td class=indexSynopsis width=100%>Unions <code>otherSet</code> with this set. The union adds all elements from <code>otherSet</code>.</td>
	</tr>
	<tr>
		<td class=indexHead colspan=3>Operators</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:foreach">for (ValueType elem : set)&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Iterates through the elements in a set.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:=="><var>set1</var> == <var>set2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Evaluates to <code>true</code> if <code>set1</code> and <code>set2</code> contain the same elements.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:!="><var>set1</var> != <var>set2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Evaluates to <code>true</code> if <code>set1</code> and <code>set2</code> are different.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:+"><var>set</var> + <var>value</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Creates a new set which is the union of <code>set</code> with the single <code>value</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:+"><var>set1</var> + <var>set2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N log N)</td>
		<td class=indexSynopsis width=100%>Creates a new set which is the union of <code>set1</code> with <code>set2</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:+="><var>set</var> += <var>value</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(log N)</td>
		<td class=indexSynopsis width=100%>Adds the single <code>value</code> to <code>set</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:+="><var>set1</var> += <var>set2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N log N)</td>
		<td class=indexSynopsis width=100%>Adds all of the elements from <code>set2</code> to <code>set1</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:-"><var>set</var> - <var>value</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Creates a new set which contains all values in <code>set</code> minus <code>value</code>.
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:-"><var>set1</var> - <var>set2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N log N)</td>
		<td class=indexSynopsis width=100%>Creates a new set containing the elements in <code>set1</code> that aren't in <code>set2</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:-="><var>set</var> -= <var>value</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(log N)</td>
		<td class=indexSynopsis width=100%>Removes the single <code>value</code> from <code>set</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:-="><var>set1</var> -= <var>set2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N log N)</td>
		<td class=indexSynopsis width=100%>Removes the elements of <code>set2</code> from <code>set1</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:*"><var>set1</var> * <var>set2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N log N)</td>
		<td class=indexSynopsis width=100%>Creates a new set which is the intersection of <code>set1</code> and <code>set2</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:*="><var>set1</var> *= <var>set2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N log N)</td>
		<td class=indexSynopsis width=100%>Removes any elements from <code>set1</code> that are not present in <code>set2</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:<<"><var>ostream</var>&nbsp;&lt;&lt;&nbsp;<var>set</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Outputs the contents of <code>set</code> to the given output stream.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:>>"><var>istream</var>&nbsp;&gt;&gt;&nbsp;<var>set</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N log N)</td>
		<td class=indexSynopsis width=100%>Reads the contents of the given input stream into <code>set</code>.</td>
	</tr>
</table>

<h2>Constructor detail</h2>

<hr>
<a name="Constructor:Set"></a>
<pre class=detailCode>
Set();
</pre>
<div class=detailHTML>
Creates an empty set of the specified element type. You may also optionally provide an initializer list of values. The newly created set will contain those values.
<p>Usage:<br>
</div>
<pre class=usageCode>
Set&lt;ValueType&gt; set;
Set&lt;ValueType&gt; set = { value1, value2, value3 };
</pre>

<hr>
</table>
<h2>Method detail</h2>

<hr>
<a name="Method:add"></a>
<pre class=detailCode>
void add(const ValueType&amp; value);
</pre>
<div class=detailHTML>
Adds an element to this set, if it was not already there.
<p>Usage:<br>
</div>
<pre class=usageCode>
set.add(value);
</pre>

<hr>
<a name="Method:clear"></a>
<pre class=detailCode>
void clear();
</pre>
<div class=detailHTML>
Removes all elements from this set.
<p>Usage:<br>
</div>
<pre class=usageCode>
set.clear();
</pre>

<hr>
<a name="Method:contains"></a>
<pre class=detailCode>
bool contains(const ValueType&amp;  value) const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if the specified value is in this set.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (set.contains(value)) ...
</pre>

<hr>
<a name="Method:difference"></a>
<pre class=detailCode>
Set&amp; difference(const Set&amp; set2);
</pre>
<div class=detailHTML>
Removes from this set all elements that are present in <code>set2</code>. Returns a reference to this set, which has been modified in place. If you want a new set, consider <code><a href="#Operator:-">set1 - set2</a></code> instead.
<p>Usage:<br>
</div>
<pre class=usageCode>
set1.difference(set2);
</pre>
<hr>
<a name="Method:equals"></a>
<pre class=detailCode>
bool equals(const Set&amp; set2) const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if the two sets contain exactly the same element values.
Identical in behavior to the <code>==</code> operator.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (set1.equals(set2)) ...
</pre>

<hr>
<a name="Method:first"></a>
<pre class=detailCode>
ValueType first() const;
</pre>
<div class=detailHTML>
Returns the first value in the set when considered in sorted order.  If set is empty, <code>first</code>
signals an error.
<p>Usage:<br>
</div>
<pre class=usageCode>
ValueType value = set.first();
</pre>

<hr>
<a name="Method:intersect"></a>
<pre class=detailCode>
Set&amp; intersect(const Set&amp; set2);
</pre>
<div class=detailHTML>
Removes from this set all elements that are not present in <code>set2</code>. Returns a reference to this set, which has been modified in place. If you want a new set, consider <code><a href="#Operator:*">set1 * set2</a></code> instead.
<p>Usage:<br>
</div>
<pre class=usageCode>
set.intersect(set2);
</pre>

<hr>
<a name="Method:isEmpty"></a>
<pre class=detailCode>
bool isEmpty() const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if this set contains no elements.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (set.isEmpty()) ...
</pre>

<hr>
<a name="Method:isSubsetOf"></a>
<pre class=detailCode>
bool isSubsetOf(const Set&amp; set2) const;
</pre>
<div class=detailHTML>
Returns
<code>true</code> if every element of this set is
contained in <code>set2</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (set1.isSubsetOf(set2)) ...
</pre>

<hr>
<a name="Method:isSupersetOf"></a>
<pre class=detailCode>
bool isSupersetOf(const Set&amp; set2) const;
</pre>
<div class=detailHTML>
Returns
<code>true</code> if every element of <code>set2</code> is
contained in this set.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (set1.isSupersetOf(set2)) ...
</pre>


<hr>
<a name="Method:last"></a>
<pre class=detailCode>
ValueType last() const;
</pre>
<div class=detailHTML>
Returns the last value in the set when considered in sorted order.  If set is empty, <code>last</code>
signals an error.
<p>Usage:<br>
</div>
<pre class=usageCode>
ValueType value = set.last();
</pre>


<hr>
<a name="Method:mapAll"></a>
<pre class=detailCode>
void mapAll(std::function&lt;void (const ValueType&amp;)&gt; fn) const;
</pre>
<div class=detailHTML>
Iterates through the elements of the set and calls <code>fn(value)</code>
for each one.  The elements are processed in sorted order.
<p>Usage:<br>
</div>
<pre class=usageCode>
set.mapAll(fn);
</pre>


<hr>
<a name="Method:remove"></a>
<pre class=detailCode>
void remove(const ValueType&amp;  value);
</pre>
<div class=detailHTML>
Removes an element from this set.  If the value was not
contained in the set, there is no error and the set
remains unchanged.
<p>Usage:<br>
</div>
<pre class=usageCode>
set.remove(value);
</pre>

<hr>
<a name="Method:size"></a>
<pre class=detailCode>
int size() const;
</pre>
<div class=detailHTML>
Returns the number of elements in this set.
<p>Usage:<br>
</div>
<pre class=usageCode>
int count = set.size();
</pre>

<hr>
<a name="Method:toString"></a>
<pre class=detailCode>
string toString() const;
</pre>
<div class=detailHTML>
Returns a printable string representation of this set, such as <code>&quot;{value1, value2, value3}&quot;</code>.
The values are listed in sorted order.
<p>Usage:<br>
</div>
<pre class=usageCode>
string str = set.toString();
</pre>

<hr>
<a name="Method:unionWith"></a>
<pre class=detailCode>
Set&amp; unionWith(const Set&amp; set2);
</pre>
<div class=detailHTML>
Adds to this set all elements from <code>set2</code>. Returns a reference to this set, which has been modified in place. If you want a new set, consider <code><a href="#Operator:+">set1 + set2</a></code> instead.
<p>Usage:<br>
</div>
<pre class=usageCode>
set1.unionWith(set2);
</pre>

<hr>
</table>
<h2>Operator detail</h2>

<hr>
<a name="Operator:foreach"></a>
<pre class=detailCode>
for (ValueType elem : set)
</pre>
<div class=detailHTML>
The range-based for loop can be used to iterate through the elements in a collection. The elements in a set are accessed in sorted order. An error is signaled if you attempt to add/remove elements from a collection while iterating over it.

<p>Usage:<br>
</div>
<pre class=usageCode>
for (ValueType elem : set) {
	cout << elem << endl;
}
</pre>


<hr>
<a name="Operator:=="></a>
<pre class=detailCode>
bool operator==(const Set&amp; set2) const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if <code>set1</code> and <code>set2</code>
contain the same elements.
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 == set2
</pre>

<hr>
<a name="Operator:!="></a>
<pre class=detailCode>
bool operator!=(const Set&amp; set2) const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if <code>set1</code> and <code>set2</code>
are different.
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 != set2
</pre>

<hr>
<a name="Operator:+"></a>
<pre class=detailCode>
Set operator+(const Set&amp; set2) const;
Set operator+(const ValueType&amp; element) const;
</pre>
<div class=detailHTML>
Creates a new set which is the union of <code>set1</code> with <code>set2</code> (or with the single <code>value</code>).
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 + set2
set1 + value
</pre>

<hr>
<a name="Operator:*"></a>
<pre class=detailCode>
Set operator*(const Set&amp; set2) const;
</pre>
<div class=detailHTML>
Creates a new set which is the intersection of <code>set1</code> and <code>set2</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 * set2
</pre>

<hr>
<a name="Operator:-"></a>
<pre class=detailCode>
Set operator-(const Set&amp; set2) const;
Set operator-(const ValueType&amp; value) const;
</pre>
<div class=detailHTML>
Creates a new set which is the difference of <code>set1</code> minus <code>set2</code> (or minus the single <code>value</code>).
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 - set2
set1 - value
</pre>

<hr>
<a name="Operator:+="></a>
<pre class=detailCode>
Set&amp; operator+=(const Set&amp; set2);
Set&amp; operator+=(const ValueType&amp; value);
</pre>
<div class=detailHTML>
Adds all of the elements from <code>set2</code> (or the single <code>value</code>) to <code>set1</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 += set2;
set1 += value;
</pre>

<hr>
<a name="Operator:*="></a>
<pre class=detailCode>
Set&amp; operator*=(const Set&amp; set2);
</pre>
<div class=detailHTML>
Removes any elements from <code>set1</code> that are not present in
<code>set2</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 *= set2;
</pre>

<hr>
<a name="Operator:-="></a>
<pre class=detailCode>
Set&amp; operator-=(const Set&amp; set2);
Set&amp; operator-=(const ValueType&amp; value);
</pre>
<div class=detailHTML>
Removes the all elements in <code>set2</code> (or the single <code>value</code>) from <code>set1</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
set1 -= set2;
set1 -= value;
</pre>

<hr>
<a name="Operator:<<"></a>
<pre class=detailCode>
ostream&amp; operator&lt;&lt;(const Set&amp; set);
</pre>
Outputs the contents of <code>set</code> to the given output stream.
The output is in the form <code>{value1, value2, value3}</code>
where elements are listed in sorted order.

<p>Usage:<br>
</div>
<pre class=usageCode>
cout << set << endl;
</pre>


<hr>
<a name="Operator:>>"></a>
<pre class=detailCode>
istream&amp; operator&gt;&gt;(Set&amp; set);
</pre>
Reads the contents of the given input stream into <code>set</code>. Any previous
contents of the set are replaced.
The input is expected to be in the form <code>{value1, value2, value3}</code>. If unable to read a proper
set from the stream, the operation results in a stream fail state.

<p>Usage:<br>
</div>
<pre class=usageCode>
if (infile >> set) ...
</pre>

<hr>
</table>
</body>
</html>
