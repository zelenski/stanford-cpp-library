<html>
<head>
<title>HashMap</title>
<link rel="stylesheet" type="text/css" href="cppdoc.css" />
</head>
<body>
<table class=banner>
<tr>
<td valign=middle><image src="img/StanfordTreeLogo.png" height=32></td>
<td valign=middle><div class=bannerText>
The Stanford <code>libcs106</code> library, Academic Year 2023-24
</div></td>
</tr></table>
<hr>
<div class=include>#include "hashmap.h"</div>
<h1 class=header><code>class HashMap&lt;<var>KeyType</var>,&nbsp;<var>ValueType</var>&gt;</code></h1>
This class implements an efficient association between
<b><i>keys</i></b> and <b><i>values</i></b>.  This class is
identical to the <a href="HashMap-class.html"><code>HashMap</code></a> class
except for the fact that it uses a hash table as its underlying
representation which allows it to operate in O(1) time.   The disadvantage of
<code>HashMap</code> is range-based for loop and other iteration patterns
will access the keys in an unpredictable and seemingly random order.
The HashMap operations to add/access/remove an entry run in O(1) time.

<table class=index width=100%>
	<tr>
		<td class=indexHead colspan=3>Constructor</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Constructor:HashMap">HashMap()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Initializes a new empty map that associates keys and values of the specified types.</td>
	</tr>
	<tr>
		<td class=indexHead colspan=2>Methods</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:clear">clear()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Removes all entries from this map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:containsKey">containsKey(<var>key</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Returns <code>true</code> if there is an entry for <code>key</code> in this map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:equals">equals(<var>map</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Returns <code>true</code> if the two maps contain the same entries.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:firstKey">firstKey()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Returns the first key in this map in the order established by a for-each loop.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:get">get(<var>key</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Returns the value associated with <code>key</code> in this map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:isEmpty">isEmpty()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Returns <code>true</code> if this map contains no entries.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:keys">keys()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Returns a <code>Vector</code> copy of all keys in this map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:lastKey">lastKey()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Returns the last value in this map in the order established by a for-each loop.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:mapAll">mapAll(<var>fn</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Iterates through the map entries and calls <code>fn(key, value)</code> for each one.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:put">put(<var>key</var>,&nbsp;<var>value</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Associates <code>key</code> with <code>value</code> in this map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:remove">remove(<var>key</var>)</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Removes any entry for <code>key</code> from this map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:size">size()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Returns the number of entries in this map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:toString">toString()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Returns a printable string representation of this map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Method:values">values()</a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Returns a <code>Vector</code> copy of all values in this map.</td>
	</tr>
	<tr>
		<td class=indexHead colspan=3>Operators</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:foreach">for (KeyType key : map)&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Iterates through the keys in a map.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:[]"><var>map</var>[<var>key</var>]</a>&nbsp;</nobr></td>
		<td class="bigoh">O(1)</td>
		<td class=indexSynopsis width=100%>Selects the value associated with <code>key</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:=="><var>map1</var> == <var>map1</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Returns <code>true</code> if <code>map1</code> and <code>map2</code> contain the same entries.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:!="><var>map1</var> != <var>map2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Returns <code>true</code> if <code>map1</code> and <code>map2</code> are different.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:+"><var>map1</var> + <var>map2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Creates a new map which contains all <code>map1</code> entries added to all <code>map2</code> entries.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:+="><var>map1</var> += <var>map2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Adds all <code>map2</code> entries to <code>map1</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:-"><var>map1</var> - <var>map2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Creates a new map which contains all <code>map1</code> entries minus all <code>map2</code> entries.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:-="><var>map1</var> -= <var>map2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Removes all <code>map2</code> entries from <code>map1</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:*"><var>map1</var> * <var>map2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Creates a new map which contains all entries that appear in both <code>map1</code> and <code>map2</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:*="><var>map1</var> *= <var>map2</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Removes any entries from <code>map1</code> that are not present in <code>map2</code>.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:<<"><var>ostream</var>&nbsp;&lt;&lt;&nbsp;<var>map</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Outputs the contents of the map to the given output stream.</td>
	</tr>
	<tr>
		<td class=indexKey><nobr><a href="#Operator:>>"><var>istream</var>&nbsp;&gt;&gt;&nbsp;<var>map</var></a>&nbsp;</nobr></td>
		<td class="bigoh">O(N)</td>
		<td class=indexSynopsis width=100%>Reads the contents of the given input stream into the map.</td>
	</tr>
</table>

<h2>Constructor detail</h2>

<hr>
<a name="Constructor:HashMap"></a>
<pre class=detailCode>
HashMap();
</pre>
<div class=detailHTML>
Initializes a new empty map that associates keys and values of the
specified types. You may also optionally provide an initializer list of key-value pairs. The newly created map will contain those entries.
<p>
	 The type used for the key must define
	the <code>==</code> operator, and there must be a free function
	with the following signature:

	<pre>
	    int hashCode(KeyType key);
	</pre>

	that returns a positive integer determined by the key.  This interface
	exports <code>hashCode</code> functions for <code>string</code> and
	the C++ primitive types.
<p>Usage:<br>
</div>
<pre class=usageCode>
HashMap&lt;KeyType, ValueType&gt; map;
HashMap&lt;KeyType, ValueType&gt; map = {{ k1, v1}, { k2, v2 }};

</pre>
<hr>
</table>

<h2>Method detail</h2>

<hr>
<a name="Method:clear"></a>
<pre class=detailCode>
void clear();
</pre>
<div class=detailHTML>
Removes all entries from this map.
<p>Usage:<br>
</div>
<pre class=usageCode>
map.clear();
</pre>

<hr>
<a name="Method:containsKey"></a>
<pre class=detailCode>
bool containsKey(const KeyType& key) const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if there is an entry for <code>key</code>
in this map.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (map.containsKey(key)) ...
</pre>

<hr>
<a name="Method:equals"></a>
<pre class=detailCode>
bool equals(const HashMap&amp; map) const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if the two maps contain exactly the same key/value pairs.
Identical in behavior to the <code>==</code> operator.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (map1.equals(map2)) ...
</pre>

<hr>
<a name="Method:firstKey"></a>
<pre class=detailCode>
KeyType firstKey() const;
</pre>
<div class=detailHTML>
Returns the first key in the map in the order established by
a for-each loop.  If map is empty, <code>firstKey</code>
signals an error.
<p>Usage:<br>
</div>
<pre class=usageCode>
KeyType first = map.firstKey();
</pre>


<hr>
<a name="Method:get"></a>
<pre class=detailCode>
ValueType get(const KeyType&amp; key) const;
</pre>
<div class=detailHTML>
Returns the value associated with <code>key</code> in this map.
If <code>key</code> is not found, <code>get</code> returns the
default value for <code>ValueType</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
ValueType value = map.get(key);
</pre>

<hr>
<a name="Method:isEmpty"></a>
<pre class=detailCode>
bool isEmpty() const;
</pre>
<div class=detailHTML>
Returns <code>true</code> if this map contains no entries.
<p>Usage:<br>
</div>
<pre class=usageCode>
if (map.isEmpty()) ...
</pre>

<hr>
<a name="Method:keys"></a>
<pre class=detailCode>
Vector&lt;KeyType&gt; keys() const;
</pre>
<div class=detailHTML>
Returns a <code>Vector</code> copy of all keys in this map.
The keys will appear in the same order that a for-each loop over the map would produce them.
Because a map cannot contain duplicate keys, the elements of the vector will be unique.
<p>Usage:<br>
</div>
<pre class=usageCode>
Vector&lt;KeyType&gt; keys = map.keys();
</pre>

<hr>
<a name="Method:lastKey"></a>
<pre class=detailCode>
KeyType lastKey() const;
</pre>
<div class=detailHTML>
Returns the last key in the map in the order established by
a for-each loop.  If map is empty, <code>lastKey</code>
signals an error.
<p>Usage:<br>
</div>
<pre class=usageCode>
KeyType last = map.lastKey();
</pre>


<hr>
<a name="Method:mapAll"></a>
<pre class=detailCode>
void mapAll(std::function&lt;void (const KeyType&amp;, const ValueType&amp;)&gt; fn) const;
</pre>
<div class=detailHTML>
Iterates through the map entries and calls <code>fn(key, value)</code>
for each one.  The entries are processed in unpredictable order.
<p>Usage:<br>
</div>
<pre class=usageCode>
map.mapAll(fn);
</pre>

<hr>
<a name="Method:put"></a>
<pre class=detailCode>
void put(const KeyType& key, const ValueType& value);
</pre>
<div class=detailHTML>
Associates <code>key</code> with <code>value</code> in this map.
Any previous value associated with <code>key</code> is replaced
by the new value.
<p>Usage:<br>
</div>
<pre class=usageCode>
map.put(key, value);
</pre>

<hr>
<a name="Method:remove"></a>
<pre class=detailCode>
void remove(const KeyType& key);
</pre>
<div class=detailHTML>
Removes any entry for <code>key</code> from this map.
<p>Usage:<br>
</div>
<pre class=usageCode>
map.remove(key);
</pre>

<hr>
<a name="Method:size"></a>
<pre class=detailCode>
int size() const;
</pre>
<div class=detailHTML>
Returns the number of entries in this map.
<p>Usage:<br>
</div>
<pre class=usageCode>
int nEntries = map.size();
</pre>

<hr>
<a name="Method:toString"></a>
<pre class=detailCode>
string toString() const;
</pre>
<div class=detailHTML>
Returns a printable string representation of this map, such as <code>&quot;{k1:v1, k2:v2, k3:v3}&quot;</code>.
The key/value pairs will be listed in unpredictable order.
<p>Usage:<br>
</div>
<pre class=usageCode>
string str = map.toString();
</pre>

<hr>
<a name="Method:values"></a>
<pre class=detailCode>
Vector&lt;ValueType&gt; values() const;
</pre>
<div class=detailHTML>
Returns a <code>Vector</code> copy of all values in this map.
The values will appear in the same order that a for-each loop over the map would produce them.
A map can contain duplicate values, so the elements of the vector are not guaranteed to be unique.
<p>Usage:<br>
</div>
<pre class=usageCode>
Vector&lt;ValueType&gt; values = map.values();
</pre>

<hr>
</table>
<h2>Operator detail</h2>

<hr>
<a name="Operator:foreach"></a>
<pre class=detailCode>
for (KeyType key : map)
</pre>
<div class=detailHTML>
The range-based for loop can be used to iterate through the elements in a collection. The iteration accesses map keys in unpredictable order. An error is signaled if you attempt to add/remove elements from a collection while iterating over it.

<p>Usage:<br>
</div>
<pre class=usageCode>
for (KeyType key : map) {
	cout << key << " = " << map[key] << endl;
}

</pre>


<hr>
<a name="Operator:[]"></a>
<pre class=detailCode>
ValueType&amp; operator[](const KeyType& key);
ValueType operator[](const KeyType& key) const;
</pre>
<div class=detailHTML>
Selects the value associated with <code>key</code>.  This syntax
makes it easy to think of a map as an "associative array"
indexed by the key type.  If <code>key</code> is already present
in the map, this function returns a reference to its associated
value.  If key is not present in the map, a new entry is created
whose value is set to the default for the value type.

<p>Note: <code>get</code> and <code>operator[]</code> have a small
but significant difference when used to retrieve the value for a key
not contained in the map. Both expressions return the default
value, but accessing <code>map[key]</code> adds this new entry
to the map while <code>map.get(key)</code> does not.

<p>Usage:<br>
</div>
<pre class=usageCode>
map[key]
</pre>

<hr>
<a name="Operator:+"></a>
<pre class=detailCode>
HashMap operator+(const HashMap&amp; map2) const;
</pre>
<div class=detailHTML>
Creates a new map which combines the entries from <code>map1</code> and <code>map2</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
map1 + map2
</pre>

<hr>
<a name="Operator:*"></a>
<pre class=detailCode>
HashMap operator*(const HashMap&amp; map2) const;
</pre>
<div class=detailHTML>
Creates a new map which contains those entries that appear in both <code>map1</code> and <code>map2</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
map1 * map2
</pre>

<hr>
<a name="Operator:-"></a>
<pre class=detailCode>
HashMap operator-(const HashMap&amp; map2) const;
</pre>
<div class=detailHTML>
Creates a new map which is the difference of the entries in <code>map1</code> minus those in <code>map2</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
map1 - map2
</pre>

<hr>
<a name="Operator:+="></a>
<pre class=detailCode>
HashMap&amp; operator+=(const HashMap&amp; map2);
</pre>
<div class=detailHTML>
Adds all of the entries from <code>map2</code> to <code>map1</code>.

<p>Usage:<br>
</div>
<pre class=usageCode>
map1 += map2;
</pre>

<hr>
<a name="Operator:*="></a>
<pre class=detailCode>
HashMap&amp; operator*=(const HashMap&amp; map2);
</pre>
<div class=detailHTML>
Removes any entries from <code>map1</code> that are not present in
<code>map2</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
map1 *= map2;
</pre>

<hr>
<a name="Operator:-="></a>
<pre class=detailCode>
HashMap&amp; operator-=(const HashMap&amp; map2);
</pre>
<div class=detailHTML>
Removes the entries in <code>map2</code> from <code>map1</code>.
<p>Usage:<br>
</div>
<pre class=usageCode>
map1 -= map2;
</pre>

<hr>
<a name="Operator:<<"></a>
<pre class=detailCode>
ostream&amp; operator&lt;&lt;(const HashMap&amp; map);
</pre>
Outputs the contents of <code>map</code> to the given output stream.
The output is in the form <code>{k1:v1, k2:v2, k3:v3}</code>. The entries
will be listed in unpredictable order.

<p>Usage:<br>
</div>
<pre class=usageCode>
cout << map << endl;
</pre>


<hr>
<a name="Operator:>>"></a>
<pre class=detailCode>
istream&amp; operator&gt;&gt;(HashMap&amp; map);
</pre>
Reads the contents of the given input stream into <code>map</code>. Any previous
contents of the map are replaced.
The input is expected to be in the form <code>{k1:v1, k2:v2, k3:v3}</code>. If unable to read a proper
map from the stream, the operation results in a stream fail state.

<p>Usage:<br>
</div>
<pre class=usageCode>
if (infile >> map) ...
</pre>


<hr>
</table>
</body>
</html>
